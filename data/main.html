<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>A3 Setup</title>
    <script>
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = '/style.css?v=' + new Date().getTime();
      document.head.appendChild(link);
    </script>
    <style>
      input[type=number]::-webkit-inner-spin-button,
      input[type=number]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type=number] {
        -moz-appearance: textfield;
      }
    </style>
    <script src="https://unpkg.com/mqtt@4.2.8/dist/mqtt.min.js"></script>
  </head>
  <body>
    <div class="header-box">
      <h1>A3 Setup</h1>
    </div>
    <div class="content main-content">
      <!-- Tabs -->
      <div class="tabs">
        <button class="tab-btn active" id="tabMainBtn" type="button">Main</button>
        <button class="tab-btn" id="tabLiveBtn" type="button">Live</button>
        <button class="tab-btn" id="tabSettingsBtn" type="button">Settings</button>
        <button class="tab-btn" id="tabWiFiBtn" type="button">WiFi</button>
      </div>
      <!-- Tab Contents -->
      <div class="tab-content active" id="tabMain">
        <div class="info-row">
          <div>
            Serial: <span id="serial-number" class="info-value">...</span>
          </div>
          <div>
            Version: <span id="ver-string" class="info-value">...</span>
          </div>
        </div>
        <div id="status-message" class="status-message"></div>
        <div class="btn-row">
          <button class="btn" id="backBtn">CHANGE</button>
        </div>
      </div>
      <div class="tab-content" id="tabLive">
        <div style="margin: 40px 0 20px 0; text-align: center;">
          <strong>Live tab content goes here.</strong>
        </div>
      </div>
      <div class="tab-content" id="tabSettings">
        <form id="settingsForm" autocomplete="off">
          <div class="settings-group" id="settingsFields">
            <!-- Mode -->
            <div class="settings-row">
              <label for="modeSelect"><strong>Mode</strong></label>
              <select id="modeSelect" name="mode">
                <option value="PLS">PLS</option>
                <option value="SLS">SLS</option>
              </select>
            </div>
            <!-- Pause Time -->
            <div class="settings-row">
              <label for="pauseTime"><strong>Pause Time</strong></label>
              <input type="text" id="pauseTime" name="pauseTime" placeholder="00:00:00" pattern="[0-9]{2}:[0-9]{2}:[0-9]{2}">
            </div>
            <!-- Time/Cycles -->
            <div class="settings-row">
              <label for="timeCyclesSelect"><strong>Time/Cycles</strong></label>
              <select id="timeCyclesSelect" name="timeCycles">
                <option value="TIME">Time</option>
                <option value="CYCLE">Cycles</option>
              </select>
            </div>
            <!-- Time/Cycles Value -->
            <div class="settings-row" id="timeCyclesValueRow">
              <label for="timeCyclesValue" id="timeCyclesValueLabel"><strong>Pump ON Time</strong></label>
              <input type="text" id="timeCyclesValue" name="timeCyclesValue" placeholder="00:00">
            </div>
            <!-- Proxy1 -->
            <div class="settings-row">
              <label for="proxy1"><strong>Proxy1</strong></label>
              <input type="checkbox" id="proxy1" name="proxy1">
            </div>
            <!-- Dwell Time (Proxy1) -->
            <div class="settings-row" id="dwellTime1Row" style="display:none;">
              <label for="dwellTime1"><strong>Dwell Time</strong></label>
              <input type="number" id="dwellTime1" name="dwellTime1" placeholder="Enter dwell time">
            </div>
            <!-- Proxy2 -->
            <div class="settings-row">
              <label for="proxy2"><strong>Proxy2</strong></label>
              <input type="checkbox" id="proxy2" name="proxy2">
            </div>
            <div class="settings-row" id="dwellTime2Row" style="display:none;">
              <label for="dwellTime2"><strong>Dwell Time Proxy2</strong></label>
              <input type="number" id="dwellTime2" name="dwellTime2" placeholder="Enter dwell time for Proxy2">
            </div>
            <!-- Level Sense -->
            <div class="settings-row">
              <label for="levelSense"><strong>Level Sense</strong></label>
              <input type="checkbox" id="levelSense" name="levelSense">
            </div>
            <div class="settings-row" id="levelSenseOptionsRow" style="display:none;">
              <label for="levelSenseOptions"><strong>Level Sense Mode</strong></label>
              <select id="levelSenseOptions" name="levelSenseOptions">
                <option value="HEF">Hall Sense</option>
                <option value="PULE">Pulse Empty</option>
                <option value="PULF">Pulse Full</option>
                <option value="LLO">Steady</option>
              </select>
            </div>
            <div class="settings-row" id="levelNoncRow" style="display:none;">
              <label for="levelNonc"><strong>Type</strong></label>
              <select id="levelNonc" name="levelNonc">
                <option value="NO">NO</option>
                <option value="NC">NC</option>
              </select>
            </div>
            <!-- Ext Lamp -->
            <div class="settings-row">
              <label for="extLamp"><strong>Ext Lamp</strong></label>
              <input type="checkbox" id="extLamp" name="extLamp">
            </div>
            <div class="settings-row" id="extLampOptionsRow" style="display:none;">
              <label for="extLampOptions"><strong>Lamp Mode</strong></label>
              <select id="extLampOptions" name="extLampOptions">
                <option value="RGB">RGB</option>
                <option value="STE">Steady</option>
                <option value="FLA">Flash</option>
              </select>
            </div>
            <!-- Blockage Current -->
            <div class="settings-row">
              <label><strong>Blockage Current</strong></label>
              <input type="checkbox" id="blockageManual" name="blockageManual">
              <span style="margin-right:8px;">Manual</span>
              <input type="checkbox" id="blockageAuto" name="blockageAuto">
              <span>Auto</span>
            </div>
            <div class="settings-row" id="blockageManualRow" style="display:none;">
              <label for="blockageManualValue"><strong>Manual Current</strong></label>
              <input type="number" id="blockageManualValue" name="blockageManualValue" placeholder="Enter motor current">
            </div>
            <div class="settings-row" id="blockageAutoRow" style="display:none;">
              <label for="blockageAutoValue"><strong>Auto Test</strong></label>
              <input type="text" id="blockageAutoValue" name="blockageAutoValue" placeholder="Pump Starting" disabled>
            </div>
            <!-- Pump2 -->
            <div class="settings-row">
              <label for="pump2"><strong>Pump2</strong></label>
              <input type="checkbox" id="pump2" name="pump2">
            </div>
            <div id="pump2SettingsGroup" style="display:none;">
              <div class="settings-row">
                <label for="pump2Mode"><strong>Mode</strong></label>
                <select id="pump2Mode" name="pump2Mode">
                  <option value="PLS">PLS</option>
                  <option value="SLS">SLS</option>
                </select>
              </div>
              <div class="settings-row">
                <label for="pump2PauseTime"><strong>Pause Time</strong></label>
                <input type="text" id="pump2PauseTime" name="pump2PauseTime" placeholder="00:00:00" pattern="[0-9]{2}:[0-9]{2}:[0-9]{2}">
              </div>
              <div class="settings-row">
                <label for="pump2TimeCyclesSelect"><strong>Time/Cycles</strong></label>
                <select id="pump2TimeCyclesSelect" name="pump2TimeCycles">
                  <option value="TIME">Time</option>
                  <option value="CYCLE">Cycles</option>
                </select>
              </div>
              <div class="settings-row" id="pump2TimeCyclesValueRow">
                <label for="pump2TimeCyclesValue" id="pump2TimeCyclesValueLabel"><strong>Pump ON Time</strong></label>
                <input type="text" id="pump2TimeCyclesValue" name="pump2TimeCyclesValue" placeholder="00:00">
              </div>
              <div class="settings-row">
                <label for="pump2Proxy1"><strong>Proxy1</strong></label>
                <input type="checkbox" id="pump2Proxy1" name="pump2Proxy1">
              </div>
              <div class="settings-row" id="pump2DwellTime1Row" style="display:none;">
                <label for="pump2DwellTime1"><strong>Dwell Time</strong></label>
                <input type="number" id="pump2DwellTime1" name="pump2DwellTime1" placeholder="Enter dwell time">
              </div>
              <div class="settings-row">
                <label for="pump2Proxy2"><strong>Proxy2</strong></label>
                <input type="checkbox" id="pump2Proxy2" name="pump2Proxy2">
              </div>
              <div class="settings-row" id="pump2DwellTime2Row" style="display:none;">
                <label for="pump2DwellTime2"><strong>Dwell Time Proxy2</strong></label>
                <input type="number" id="pump2DwellTime2" name="pump2DwellTime2" placeholder="Enter dwell time for Proxy2">
              </div>
              <div class="settings-row">
                <label for="pump2LevelSense"><strong>Level Sense</strong></label>
                <input type="checkbox" id="pump2LevelSense" name="pump2LevelSense">
              </div>
              <div class="settings-row" id="pump2LevelSenseOptionsRow" style="display:none;">
                <label for="pump2LevelSenseOptions"><strong>Level Sense Mode</strong></label>
                <select id="pump2LevelSenseOptions" name="pump2LevelSenseOptions">
                  <option value="HEF">Hall Sense</option>
                  <option value="PULE">Pulse Empty</option>
                  <option value="PULF">Pulse Full</option>
                  <option value="LLO">Steady</option>
                </select>
              </div>
              <div class="settings-row" id="pump2LevelNoncRow" style="display:none;">
                <label for="pump2LevelNonc"><strong>Type</strong></label>
                <select id="pump2LevelNonc" name="pump2LevelNonc">
                  <option value="NO">NO</option>
                  <option value="NC">NC</option>
                </select>
              </div>
              <div class="settings-row">
                <label><strong>Blockage Current</strong></label>
                <input type="checkbox" id="pump2BlockageManual" name="pump2BlockageManual">
                <span style="margin-right:8px;">Manual</span>
                <input type="checkbox" id="pump2BlockageAuto" name="pump2BlockageAuto">
                <span>Auto</span>
              </div>
              <div class="settings-row" id="pump2BlockageManualRow" style="display:none;">
                <label for="pump2BlockageManualValue"><strong>Manual Current</strong></label>
                <input type="number" id="pump2BlockageManualValue" name="pump2BlockageManualValue" placeholder="Enter motor current">
              </div>
              <div class="settings-row" id="pump2BlockageAutoRow" style="display:none;">
                <label for="pump2BlockageAutoValue"><strong>Auto Test</strong></label>
                <input type="text" id="pump2BlockageAutoValue" name="pump2BlockageAutoValue" placeholder="Pump Starting" disabled>
              </div>
            </div>
          </div>
          <div class="btn-row" id="testModeBtnRow" style="margin-bottom:10px;">
            <button type="button" class="btn" id="testModeBtn">Test</button>
            <button type="submit" class="btn" id="saveSettingsBtn">Save Settings</button>
          </div>
        </form>
        <!-- Test Mode UI (hidden by default) -->
        <div id="testModePanel" style="display:none;">
          <div class="testmode-panel-container">
            <div class="testmode-row">
              <span class="testmode-label">Pump1</span>
              <button type="button" class="btn testmode-pump-btn pump-on" id="pump1TestBtn">ON</button>
            </div>
            <div class="testmode-row" id="pump2TestRow" style="display:none;">
              <span class="testmode-label">Pump2</span>
              <button type="button" class="btn testmode-pump-btn pump-on" id="pump2TestBtn">ON</button>
            </div>
            <div class="testmode-row" id="proxy1Row">
              <span class="testmode-label">Proxy1</span>
              <span class="testmode-indicator proxy-off" id="proxy1Indicator">OFF</span>
            </div>
            <div class="testmode-row" id="proxy2Row">
              <span class="testmode-label">Proxy2</span>
              <span class="testmode-indicator proxy-off" id="proxy2Indicator">OFF</span>
            </div>
            <!-- ADD pump2 proxy indicators -->
            <div class="testmode-row" id="pump2Proxy1Row" style="display:none;">
              <span class="testmode-label">P2 Proxy1</span>
              <span class="testmode-indicator proxy-off" id="pump2Proxy1Indicator">OFF</span>
            </div>
            <div class="testmode-row" id="pump2Proxy2Row" style="display:none;">
              <span class="testmode-label">P2 Proxy2</span>
              <span class="testmode-indicator proxy-off" id="pump2Proxy2Indicator">OFF</span>
            </div>
          </div>
          <div class="btn-row" style="margin-top:24px;">
            <button type="button" class="btn" id="testModeBackBtn">Back</button>
            <button type="submit" class="btn" id="testModeSaveBtn">Save Settings</button>
          </div>
        </div>
      </div>
      <div class="tab-content" id="tabWiFi">
        <form id="wifiFormMain" autocomplete="off">
          <div class="fields-flex">
            <div class="input-group">
              <label for="ssid-main">WiFi Name:</label>
              <input type="text" id="ssid-main" name="ssid" required>
            </div>
            <div class="input-group">
              <label for="password-main">WiFi Password:</label>
              <input type="password" id="password-main" name="password" required>
            </div>
          </div>
          <div class="btn-row">
            <button type="submit" class="btn">SAVE</button>
          </div>
        </form>
      </div>
    </div>
    <script>
      let lastBlockCurrentP1Value = undefined;
      let userBlockCurrentP1Value = undefined;
      let latestSettingsPayload = { p1: null, p2: null, xtra: null };
      let p1AutoCalibrating = false;
      let p2AutoCalibrating = false;
      let isAlreadyConnected = false; // ADD this line

      // Blockage Current logic for Pump1
      const blockageManual = document.getElementById('blockageManual');
      const blockageAuto = document.getElementById('blockageAuto');
      const blockageManualRow = document.getElementById('blockageManualRow');
      const blockageAutoRow = document.getElementById('blockageAutoRow');
      const blockageManualValue = document.getElementById('blockageManualValue');
      const blockageAutoValue = document.getElementById('blockageAutoValue');

      // Blockage Current logic for Pump2
      const pump2BlockageManual = document.getElementById('pump2BlockageManual');
      const pump2BlockageAuto = document.getElementById('pump2BlockageAuto');
      const pump2BlockageManualRow = document.getElementById('pump2BlockageManualRow');
      const pump2BlockageAutoRow = document.getElementById('pump2BlockageAutoRow');
      const pump2BlockageManualValue = document.getElementById('pump2BlockageManualValue');
      const pump2BlockageAutoValue = document.getElementById('pump2BlockageAutoValue');

      // Track pump state for correct MQTT payload
      let pump1IsOn = false;
      let pump2IsOn = false; // ADD this line

      // Add pump1 test button click handler
      const pump1TestBtn = document.getElementById('pump1TestBtn');
      if (pump1TestBtn) {
        pump1TestBtn.onclick = function() {
          if (client && client.connected && serial) {
            const payload = pump1IsOn ? "off" : "on";
            client.publish(`a3/${serial}/test/pump1`, payload);
            console.log(`Published test command for Pump1: ${payload}`);
          }
        };
      }

      // ADD pump2 test button click handler
      const pump2TestBtn = document.getElementById('pump2TestBtn');
      if (pump2TestBtn) {
        pump2TestBtn.onclick = function() {
          if (client && client.connected && serial) {
            const payload = pump2IsOn ? "off" : "on";
            client.publish(`a3/${serial}/test/pump2`, payload);
            console.log(`Published test command for Pump2: ${payload}`);
          }
        };
      }

      // Track user edits
      blockageManualValue.addEventListener('input', function() {
        userBlockCurrentP1Value = this.value;
      });

      // Auto calibration functions
      function startP1AutoCalibration() {
        if (client && client.connected && serial) {
          p1AutoCalibrating = true;
          client.publish(`a3/${serial}/test/pump1`, "currentAutoCalibrate");
          console.log("Started P1 auto calibration");
        }
      }

      function startP2AutoCalibration() {
        console.log("startP2AutoCalibration called");
        console.log("Client exists:", !!client);
        console.log("Client connected:", client && client.connected);
        console.log("Serial:", serial);
        
        if (client && client.connected && serial) {
          p2AutoCalibrating = true;
          const topic = `a3/${serial}/test/pump2`;
          const result = client.publish(topic, "currentAutoCalibrate");
          console.log("Published to topic:", topic);
          console.log("Publish result:", result);
          console.log("Started P2 auto calibration - p2AutoCalibrating set to:", p2AutoCalibrating);
        } else {
          console.log("Cannot start P2 auto calibration - requirements not met");
        }
      }

      // Time conversion functions
      function secondsToHMS(seconds) {
        const totalSeconds = parseInt(seconds);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const secs = totalSeconds % 60;
        
        return String(hours).padStart(2, '0') + ':' + 
               String(minutes).padStart(2, '0') + ':' + 
               String(secs).padStart(2, '0');
      }

      function secondsToMS(seconds) {
        const totalSeconds = parseInt(seconds);
        const minutes = Math.floor(totalSeconds / 60);
        const secs = totalSeconds % 60;
        
        return String(minutes).padStart(2, '0') + ':' + 
               String(secs).padStart(2, '0');
      }

      function msToSeconds(msString) {
        const parts = msString.split(':');
        if (parts.length !== 2) return 0;
        
        const minutes = parseInt(parts[0]) || 0;
        const seconds = parseInt(parts[1]) || 0;
        
        return (minutes * 60) + seconds;
      }

      function hmsToSeconds(hmsString) {
        const parts = hmsString.split(':');
        if (parts.length !== 3) return 0;
        
        const hours = parseInt(parts[0]) || 0;
        const minutes = parseInt(parts[1]) || 0;
        const seconds = parseInt(parts[2]) || 0;
        
        return (hours * 3600) + (minutes * 60) + seconds;
      }

      function validateHMSInput(input) {
        input.addEventListener('input', function() {
          let value = this.value.replace(/[^0-9:]/g, '');
          
          // Auto-format as user types
          if (value.length === 2 && !value.includes(':')) {
            value += ':';
          } else if (value.length === 5 && value.split(':').length === 2) {
            value += ':';
          }
          
          this.value = value;
        });

        input.addEventListener('blur', function() {
          let value = this.value;
          const parts = value.split(':');
          
          // Ensure we have 3 parts
          while (parts.length < 3) {
            parts.push('00');
          }
          
          // Validate and format each part
          const hours = Math.max(0, Math.min(99, parseInt(parts[0]) || 0));
          const minutes = Math.max(0, Math.min(59, parseInt(parts[1]) || 0));
          const seconds = Math.max(0, Math.min(59, parseInt(parts[2]) || 0));
          
          this.value = String(hours).padStart(2, '0') + ':' + 
                       String(minutes).padStart(2, '0') + ':' + 
                       String(seconds).padStart(2, '0');
        });
      }

      function validateMSInput(input) {
        input.addEventListener('input', function() {
          let value = this.value.replace(/[^0-9:]/g, '');
          
          // Auto-format as user types
          if (value.length === 2 && !value.includes(':')) {
            value += ':';
          }
          
          this.value = value;
        });

        input.addEventListener('blur', function() {
          let value = this.value;
          const parts = value.split(':');
          
          // Ensure we have 2 parts
          while (parts.length < 2) {
            parts.push('00');
          }
          
          // Validate and format each part
          const minutes = Math.max(0, Math.min(999, parseInt(parts[0]) || 0));
          const seconds = Math.max(0, Math.min(59, parseInt(parts[1]) || 0));
          
          this.value = String(minutes).padStart(2, '0') + ':' + 
                       String(seconds).padStart(2, '0');
        });
      }

      // Apply validation to inputs
      validateHMSInput(document.getElementById('pauseTime'));
      validateHMSInput(document.getElementById('pump2PauseTime'));
      validateMSInput(document.getElementById('timeCyclesValue'));
      validateMSInput(document.getElementById('pump2TimeCyclesValue'));

      function updateBlockageRows() {
        const autoLabel = document.querySelector('label[for="blockageAutoValue"]');
        
        if (blockageManual.checked) {
          blockageManualRow.style.display = '';
          blockageAutoRow.style.display = 'none';
          if (userBlockCurrentP1Value !== undefined && userBlockCurrentP1Value !== '') {
            blockageManualValue.value = userBlockCurrentP1Value;
          } else if (lastBlockCurrentP1Value !== undefined && lastBlockCurrentP1Value !== null && lastBlockCurrentP1Value !== '') {
            blockageManualValue.value = lastBlockCurrentP1Value;
          } else {
            blockageManualValue.value = '';
            blockageManualValue.placeholder = 'Enter motor current';
          }
        } else if (blockageAuto.checked) {
          blockageManualRow.style.display = 'none';
          blockageAutoRow.style.display = '';
          if (autoLabel) {
            autoLabel.innerHTML = '<strong>Auto Test</strong>';
          }
          if (!p1AutoCalibrating) {
            blockageAutoValue.value = 'Pump Starting';
            // Start auto calibration when auto is selected
            startP1AutoCalibration();
          }
        } else {
          blockageManualRow.style.display = 'none';
          blockageAutoRow.style.display = 'none';
          p1AutoCalibrating = false;
        }
      }

      function updatePump2BlockageRows() {
        console.log("updatePump2BlockageRows called");
        const pump2AutoLabel = document.querySelector('label[for="pump2BlockageAutoValue"]');
        
        if (pump2BlockageManual.checked) {
          console.log("Pump2 Manual checked");
          pump2BlockageManualRow.style.display = '';
          pump2BlockageAutoRow.style.display = 'none';
        } else if (pump2BlockageAuto.checked) {
          console.log("Pump2 Auto checked");
          pump2BlockageManualRow.style.display = 'none';
          pump2BlockageAutoRow.style.display = '';
          if (pump2AutoLabel) {
            pump2AutoLabel.innerHTML = '<strong>Auto Test</strong>';
          }
          if (!p2AutoCalibrating) {
            console.log("p2AutoCalibrating is false, starting calibration");
            pump2BlockageAutoValue.value = 'Pump Starting';
            startP2AutoCalibration();
          } else {
            console.log("p2AutoCalibrating is already true, skipping");
          }
        } else {
          console.log("Neither pump2 manual nor auto checked");
          pump2BlockageManualRow.style.display = 'none';
          pump2BlockageAutoRow.style.display = 'none';
          p2AutoCalibrating = false;
        }
      }

      blockageManual.addEventListener('change', updateBlockageRows);
      blockageAuto.addEventListener('change', updateBlockageRows);
      pump2BlockageManual.addEventListener('change', updatePump2BlockageRows);
      pump2BlockageAuto.addEventListener('change', updatePump2BlockageRows);

      // Dynamic label updates for Time/Cycles
      function updateTimeCyclesLabel() {
        const timeCyclesSelect = document.getElementById('timeCyclesSelect');
        const timeCyclesValueLabel = document.getElementById('timeCyclesValueLabel');
        const timeCyclesValue = document.getElementById('timeCyclesValue');
        
        if (timeCyclesSelect.value === 'TIME') {
          timeCyclesValueLabel.innerHTML = '<strong>Pump ON Time</strong>';
          timeCyclesValue.placeholder = '00:00';
        } else if (timeCyclesSelect.value === 'CYCLE') {
          timeCyclesValueLabel.innerHTML = '<strong>Pump ON Cycles</strong>';
          timeCyclesValue.placeholder = 'Enter cycles';
        }
      }

      function updatePump2TimeCyclesLabel() {
        const pump2TimeCyclesSelect = document.getElementById('pump2TimeCyclesSelect');
        const pump2TimeCyclesValueLabel = document.getElementById('pump2TimeCyclesValueLabel');
        const pump2TimeCyclesValue = document.getElementById('pump2TimeCyclesValue');
        
        if (pump2TimeCyclesSelect.value === 'TIME') {
          pump2TimeCyclesValueLabel.innerHTML = '<strong>Pump ON Time</strong>';
          pump2TimeCyclesValue.placeholder = '00:00';
        } else if (pump2TimeCyclesSelect.value === 'CYCLE') {
          pump2TimeCyclesValueLabel.innerHTML = '<strong>Pump ON Cycles</strong>';
          pump2TimeCyclesValue.placeholder = 'Enter cycles';
        }
      }

      document.getElementById('timeCyclesSelect').addEventListener('change', updateTimeCyclesLabel);
      document.getElementById('pump2TimeCyclesSelect').addEventListener('change', updatePump2TimeCyclesLabel);

      // Tab switching logic
      const tabMainBtn = document.getElementById('tabMainBtn');
      const tabLiveBtn = document.getElementById('tabLiveBtn');
      const tabSettingsBtn = document.getElementById('tabSettingsBtn');
      const tabWiFiBtn = document.getElementById('tabWiFiBtn');
      const tabMain = document.getElementById('tabMain');
      const tabLive = document.getElementById('tabLive');
      const tabSettings = document.getElementById('tabSettings');
      const tabWiFi = document.getElementById('tabWiFi');

      function switchAwayFromSettings() {
        // Send pump off messages when switching away from settings tab
        const testModePanel = document.getElementById('testModePanel');
        if (testModePanel && testModePanel.style.display !== 'none') {
          sendPumpOffMessages();
        }
      }

      // Add these variables at the top to store device info
      let deviceSerial = null;
      let deviceVersion = null;

      // Update the main tab click handler
      tabMainBtn.onclick = function() {
        switchAwayFromSettings();
        tabMainBtn.classList.add('active');
        tabLiveBtn.classList.remove('active');
        tabSettingsBtn.classList.remove('active');
        tabWiFiBtn.classList.remove('active');
        tabMain.classList.add('active');
        tabLive.classList.remove('active');
        tabSettings.classList.remove('active');
        tabWiFi.classList.remove('active');
        
        // CHANGE: Always restore device info from localStorage first
        const storedSerial = localStorage.getItem('deviceSerial');
        const storedVersion = localStorage.getItem('deviceVersion');
        
        if (storedSerial) {
          deviceSerial = storedSerial;
          document.getElementById("serial-number").textContent = deviceSerial;
        }
        if (storedVersion) {
          deviceVersion = storedVersion;
          document.getElementById("ver-string").textContent = deviceVersion;
        }
        
        // Only try to connect if we don't have ANY device info
        if (!deviceSerial && !deviceVersion) {
          connectMQTTAndQuery();
        } else {
          showStatus("");
        }
      };
      tabLiveBtn.onclick = function() {
        switchAwayFromSettings(); // ADD this line
        tabLiveBtn.classList.add('active');
        tabMainBtn.classList.remove('active');
        tabSettingsBtn.classList.remove('active');
        tabWiFiBtn.classList.remove('active');
        tabLive.classList.add('active');
        tabMain.classList.remove('active');
        tabSettings.classList.remove('active');
        tabWiFi.classList.remove('active');
      };
      // Update the Settings tab click handler
      tabSettingsBtn.onclick = function() {
        // Show loading message
        showStatus("Loading device settings...", false);
        console.log("Settings tab clicked, preloading settings...");
        
        // Set flag for pre-loading
        window.preloadingForSettingsTab = true;
        
        // Connect and query settings (reuse existing logic)
        connectMQTTAndQuery(true);
      };

      // ADD: New function to handle tab switch after settings load
      function showSettingsTabAfterLoad() {
        // Clear the flag
        window.preloadingForSettingsTab = false;
        
        // Now actually switch to Settings tab
        switchAwayFromSettings();
        tabMainBtn.classList.remove('active');
        tabLiveBtn.classList.remove('active');
        tabSettingsBtn.classList.add('active');
        tabWiFiBtn.classList.remove('active');
        tabMain.classList.remove('active');
        tabLive.classList.remove('active');
        tabSettings.classList.add('active');
        tabWiFi.classList.remove('active');

        // ADD: Set up pump2 visibility handler AFTER settings are applied and visibility is set
        setTimeout(() => {
          setupShowHideCheckbox('pump2', 'pump2SettingsGroup');
          console.log("setupShowHideCheckbox called for pump2 after tab load");
        }, 100);
        
        showStatus("Settings loaded.", false);
      }

      // NEW: Pre-load settings before showing the Settings tab
      function preloadSettingsBeforeTab() {
        // Set timeout for pre-loading
        const timeout = setTimeout(() => {
          showStatus("Failed to load settings. Showing defaults.", true);
          actuallyShowSettingsTab();
        }, 8000);
        
        window.preloadTimeout = timeout;
        
        if (client && client.connected && serial) {
          // Reset settings payload
          latestSettingsPayload = { p1: null, p2: null, xtra: null };
          
          // Query for all settings
          client.publish(`a3/${serial}/queryP1Settings`, serial);
          client.publish(`a3/${serial}/queryP2Settings`, serial);
          client.publish(`a3/${serial}/queryXtraSettings`, serial);
        } else {
          // No connection - just show the tab
          clearTimeout(timeout);
          actuallyShowSettingsTab();
        }
      }

      // NEW: Actually show the Settings tab after pre-loading
      function actuallyShowSettingsTab() {
        // Clear the pre-loading flag
        window.preloadingForSettingsTab = false;
        
        // Now perform the actual tab switch
        switchAwayFromSettings();
        tabMainBtn.classList.remove('active');
        tabLiveBtn.classList.remove('active');
        tabSettingsBtn.classList.add('active');
        tabWiFiBtn.classList.remove('active');
        tabMain.classList.remove('active');
        tabLive.classList.remove('active');
        tabSettings.classList.add('active');
        tabWiFi.classList.remove('active');

        // Set up pump2 show/hide after everything is loaded
        setupShowHideCheckbox('pump2', 'pump2SettingsGroup');
        
        showStatus("Settings loaded.", false);
      }

      // MODIFY: Fix the setupShowHideCheckbox function to properly handle initial state
function setupShowHideCheckbox(checkboxId, targetId) {
  const checkbox = document.getElementById(checkboxId);
  const target = document.getElementById(targetId);
  
  if (!checkbox || !target) return;
  
  function updateVisibility() {
    target.style.display = checkbox.checked ? '' : 'none';
  }
  
  // FIXED: Properly set initial state based on current checkbox value
  updateVisibility();
  
  // Remove any existing event listener to avoid duplicates
  checkbox.removeEventListener('change', updateVisibility);
  
  // Add the event listener
  checkbox.addEventListener('change', updateVisibility);
}

      document.getElementById('levelSenseOptions').addEventListener('change', function() {
        const noncRow = document.getElementById('levelNoncRow');
        if (this.value === 'LLO') {
          noncRow.style.display = '';
        } else {
          noncRow.style.display = 'none';
        }
      });

      document.getElementById('pump2LevelSenseOptions').addEventListener('change', function() {
        const noncRow = document.getElementById('pump2LevelNoncRow');
        if (this.value === 'LLO') {
          noncRow.style.display = '';
        } else {
          noncRow.style.display = 'none';
        }
      });

      // Test Mode logic
      const testModeBtn = document.getElementById('testModeBtn');
      const testModePanel = document.getElementById('testModePanel');
      const settingsForm = document.getElementById('settingsForm');
      const testModeBackBtn = document.getElementById('testModeBackBtn');
      const proxy1Row = document.getElementById('proxy1Row');
      const proxy2Row = document.getElementById('proxy2Row');
      const pump2Proxy1Row = document.getElementById('pump2Proxy1Row'); // ADD
      const pump2Proxy2Row = document.getElementById('pump2Proxy2Row'); // ADD

      function updateProxyRowsVisibility() {
        proxy1Row.style.display = document.getElementById('proxy1').checked ? '' : 'none';
        proxy2Row.style.display = document.getElementById('proxy2').checked ? '' : 'none';
        
        // ADD pump2 visibility logic
        const pump2TestRow = document.getElementById('pump2TestRow');
        pump2TestRow.style.display = document.getElementById('pump2').checked ? '' : 'none';
        
        // ADD pump2 proxy visibility logic
        const pump2Proxy1Row = document.getElementById('pump2Proxy1Row');
        const pump2Proxy2Row = document.getElementById('pump2Proxy2Row');
        const pump2InUse = document.getElementById('pump2').checked;
        const pump2Proxy1Enabled = document.getElementById('pump2Proxy1').checked;
        const pump2Proxy2Enabled = document.getElementById('pump2Proxy2').checked;
        
        pump2Proxy1Row.style.display = (pump2InUse && pump2Proxy1Enabled) ? '' : 'none';
        pump2Proxy2Row.style.display = (pump2InUse && pump2Proxy2Enabled) ? '' : 'none';
      }

      testModeBtn.onclick = function() {
        settingsForm.style.display = 'none';
        testModePanel.style.display = '';
        updateProxyRowsVisibility();
        initializeTestModeButtons(); // ADD this line
      };
      testModeBackBtn.onclick = function() {
        sendPumpOffMessages(); // ADD this line
        testModePanel.style.display = 'none';
        settingsForm.style.display = '';
      };

      // UPDATE the initializeTestModeButtons function - SWAP INITIAL CLASSES
      function initializeTestModeButtons() {
        // Initialize pump1 button - GREEN background, ON label (pump is stopped initially)
        const pump1TestBtn = document.getElementById('pump1TestBtn');
        if (pump1TestBtn) {
          pump1TestBtn.classList.remove('pump-on');  // Remove red
          pump1TestBtn.classList.add('pump-off');    // Add green
          pump1TestBtn.textContent = "ON";
          pump1IsOn = false; // Pump is actually off when button shows ON
        }
        
        // Initialize pump2 button - GREEN background, ON label (pump is stopped initially)
        const pump2TestBtn = document.getElementById('pump2TestBtn');
        if (pump2TestBtn) {
          pump2TestBtn.classList.remove('pump-on');  // Remove red
          pump2TestBtn.classList.add('pump-off');    // Add green
          pump2TestBtn.textContent = "ON";
          pump2IsOn = false; // Pump is actually off when button shows ON
        }
        
        // Initialize proxy indicators - gray background, OFF label (unchanged)
        const proxy1Indicator = document.getElementById('proxy1Indicator');
        const proxy2Indicator = document.getElementById('proxy2Indicator');
        const pump2Proxy1Indicator = document.getElementById('pump2Proxy1Indicator');
        const pump2Proxy2Indicator = document.getElementById('pump2Proxy2Indicator');
        
        if (proxy1Indicator) {
          proxy1Indicator.classList.add('proxy-off');
          proxy1Indicator.classList.remove('proxy-on');
          proxy1Indicator.textContent = "OFF";
        }
        if (proxy2Indicator) {
          proxy2Indicator.classList.add('proxy-off');
          proxy2Indicator.classList.remove('proxy-on');
          proxy2Indicator.textContent = "OFF";
        }
        if (pump2Proxy1Indicator) {
          pump2Proxy1Indicator.classList.add('proxy-off');
          pump2Proxy1Indicator.classList.remove('proxy-on');
          pump2Proxy1Indicator.textContent = "OFF";
        }
        if (pump2Proxy2Indicator) {
          pump2Proxy2Indicator.classList.add('proxy-off');
          pump2Proxy2Indicator.classList.remove('proxy-on');
          pump2Proxy2Indicator.textContent = "OFF";
        }
      }

      // UPDATE the sendPumpOffMessages function
      function sendPumpOffMessages() {
        if (client && client.connected && serial) {
          // Send OFF messages to both pumps
          client.publish(`a3/${serial}/test/pump1`, "off");
          client.publish(`a3/${serial}/test/pump2`, "off");
          console.log("Sent OFF messages to both pumps");
        }
      }

      // MQTT config
      const hivemqBrokerUrl = 'wss://bd58f8878eef4f5eb73ac65312b10130.s1.eu.hivemq.cloud:8884/mqtt';
      const hivemqUsername = 'a3Admin';
      const hivemqPassword = 'DontLetMeIn247';

      let client = null;
      let serial = null;
      let queryTimeout = null;

      function getSerialFromURL() {
        const params = new URLSearchParams(window.location.search);
        return params.get("serial");
      }

      function showStatus(msg, isError = false) {
        const status = document.getElementById("status-message");
        status.textContent = msg;
        status.className = "status-message" + (isError ? " error" : "");
      }

      function isChecked(val) {
        if (typeof val === "boolean") return val;
        if (typeof val === "string") return val.toUpperCase() === "YES" || val.toLowerCase() === "true";
        if (typeof val === "number") return val === 1;
        return false;
      }

      function applySettingsFromPayload(payloads) {
        console.log("applySettingsFromPayload called with:", payloads);
        
        // PREVENT DUPLICATES: Check if we're already processing settings
        if (window.processingSettings) {
          console.log("Settings already being processed - ignoring duplicate call");
          return;
        }
        
        // Set flag to prevent duplicates
        window.processingSettings = true;
        window.isLoadingSettings = true;
        
        try {
          // ...existing code... (all your current parsing and setting code stays the same)
          
          // At the very end, in your setTimeout:
          setTimeout(() => {
            console.log("Applying visibility logic only...");
            applyVisibilityOnlyForLoadedSettings();
            
            const pump2Enabled = document.getElementById('pump2').checked;
            console.log("Pump2 enabled after settings load:", pump2Enabled);
            
            if (pump2Enabled) {
              console.log("Triggering pump2 change event to apply visibility");
              document.getElementById('pump2').dispatchEvent(new Event('change'));
            } else {
              console.log("Pump2 disabled - skipping change event trigger");
            }
            
            // Clear ALL flags
            window.isLoadingSettings = false;
            window.processingSettings = false;
            
            console.log("Settings loading complete, flags cleared");
          }, 50);

        } catch (e) {
          // Clear flags on error
          window.isLoadingSettings = false;
          window.processingSettings = false;
          console.error("applySettingsFromPayload error:", e);
        }
        
        try {
          const settingsP1 = payloads.p1 ? JSON.parse(payloads.p1) : {};
          const settingsP2 = payloads.p2 ? JSON.parse(payloads.p2) : {};
          const settingsXtra = payloads.xtra ? JSON.parse(payloads.xtra) : {};

          console.log("Parsed P1 settings:", settingsP1);
          console.log("Parsed P2 settings:", settingsP2);
          console.log("Parsed Xtra settings:", settingsXtra);

          // Apply P1 settings
          if (settingsP1.modeP1) {
            document.getElementById('modeSelect').value = settingsP1.modeP1;
            console.log("Set modeSelect to:", settingsP1.modeP1);
          }
          
          if (settingsP1.pauseTimeP1 !== undefined) {
            document.getElementById('pauseTime').value = secondsToHMS(settingsP1.pauseTimeP1);
            console.log("Set pauseTime to:", secondsToHMS(settingsP1.pauseTimeP1));
          }
          
          if (settingsP1.runModeP1) {
            document.getElementById('timeCyclesSelect').value = settingsP1.runModeP1;
            console.log("Set timeCyclesSelect to:", settingsP1.runModeP1);
          }
          
          if (settingsP1.timeCyclesP1 !== undefined) {
            const timeCyclesValue = settingsP1.runModeP1 === 'TIME' ? 
              secondsToMS(settingsP1.timeCyclesP1) : 
              settingsP1.timeCyclesP1.toString();
            document.getElementById('timeCyclesValue').value = timeCyclesValue;
            console.log("Set timeCyclesValue to:", timeCyclesValue);
          }
          
          if (settingsP1.proxy1P1 !== undefined) {
            const proxy1Checkbox = document.getElementById('proxy1');
            const shouldBeChecked = settingsP1.proxy1P1 === "YES";
            proxy1Checkbox.checked = shouldBeChecked;
            console.log("Set proxy1 checkbox to:", shouldBeChecked, "actual value:", proxy1Checkbox.checked);
          }
          
          if (settingsP1.proxy2P1 !== undefined) {
            const proxy2Checkbox = document.getElementById('proxy2');
            const shouldBeChecked = settingsP1.proxy2P1 === "YES";
            proxy2Checkbox.checked = shouldBeChecked;
            console.log("Set proxy2 checkbox to:", shouldBeChecked, "actual value:", proxy2Checkbox.checked);
          }
          
          if (settingsP1.dwellTimeP1Px1 !== undefined) {
            document.getElementById('dwellTime1').value = settingsP1.dwellTimeP1Px1.toString();
            console.log("Set dwellTime1 to:", settingsP1.dwellTimeP1Px1.toString());
          }
          
          if (settingsP1.dwellTimeP1Px2 !== undefined) {
            document.getElementById('dwellTime2').value = settingsP1.dwellTimeP1Px2.toString();
            console.log("Set dwellTime2 to:", settingsP1.dwellTimeP1Px2.toString());
          }
          
          if (settingsP1.levelP1 !== undefined) {
            const levelSenseCheckbox = document.getElementById('levelSense');
            const shouldBeChecked = settingsP1.levelP1 === "YES";
            levelSenseCheckbox.checked = shouldBeChecked;
            console.log("Set levelSense checkbox to:", shouldBeChecked, "actual value:", levelSenseCheckbox.checked);
          }
          
          if (settingsP1.levelTypeP1) {
            document.getElementById('levelSenseOptions').value = settingsP1.levelTypeP1;
            console.log("Set levelSenseOptions to:", settingsP1.levelTypeP1);
          }
          
          if (settingsP1.levelNoncP1) {
            document.getElementById('levelNonc').value = settingsP1.levelNoncP1;
            console.log("Set levelNonc to:", settingsP1.levelNoncP1);
          }

          // Apply P2 settings
          if (settingsP2.pump2InUse !== undefined) {
            const pump2Checkbox = document.getElementById('pump2');
            const shouldBeChecked = settingsP2.pump2InUse === "YES";
            pump2Checkbox.checked = shouldBeChecked;
            console.log("Set pump2 checkbox to:", shouldBeChecked, "actual value:", pump2Checkbox.checked);
          }
          
          if (settingsP2.modeP2) {
            document.getElementById('pump2Mode').value = settingsP2.modeP2;
            console.log("Set pump2Mode to:", settingsP2.modeP2);
          }
          
          if (settingsP2.pauseTimeP2 !== undefined) {
            document.getElementById('pump2PauseTime').value = secondsToHMS(settingsP2.pauseTimeP2);
            console.log("Set pump2PauseTime to:", secondsToHMS(settingsP2.pauseTimeP2));
          }
          
          if (settingsP2.runModeP2) {
            document.getElementById('pump2TimeCyclesSelect').value = settingsP2.runModeP2;
            console.log("Set pump2TimeCyclesSelect to:", settingsP2.runModeP2);
          }
          
          if (settingsP2.timeCyclesP2 !== undefined) {
            const pump2TimeCyclesValue = settingsP2.runModeP2 === 'TIME' ? 
              secondsToMS(settingsP2.timeCyclesP2) : 
              settingsP2.timeCyclesP2.toString();
            document.getElementById('pump2TimeCyclesValue').value = pump2TimeCyclesValue;
            console.log("Set pump2TimeCyclesValue to:", pump2TimeCyclesValue);
          }
          
          if (settingsP2.proxy1P2 !== undefined) {
            const pump2Proxy1Checkbox = document.getElementById('pump2Proxy1');
            const shouldBeChecked = settingsP2.proxy1P2 === "YES";
            pump2Proxy1Checkbox.checked = shouldBeChecked;
            console.log("Set pump2Proxy1 checkbox to:", shouldBeChecked, "actual value:", pump2Proxy1Checkbox.checked);
          }
          
          if (settingsP2.proxy2P2 !== undefined) {
            const pump2Proxy2Checkbox = document.getElementById('pump2Proxy2');
            const shouldBeChecked = settingsP2.proxy2P2 === "YES";
            pump2Proxy2Checkbox.checked = shouldBeChecked;
            console.log("Set pump2Proxy2 checkbox to:", shouldBeChecked, "actual value:", pump2Proxy2Checkbox.checked);
          }
          
          if (settingsP2.dwellTimeP2Px1 !== undefined) {
            document.getElementById('pump2DwellTime1').value = settingsP2.dwellTimeP2Px1.toString();
            console.log("Set pump2DwellTime1 to:", settingsP2.dwellTimeP2Px1.toString());
          }
          
          if (settingsP2.dwellTimeP2Px2 !== undefined) {
            document.getElementById('pump2DwellTime2').value = settingsP2.dwellTimeP2Px2.toString();
            console.log("Set pump2DwellTime2 to:", settingsP2.dwellTimeP2Px2.toString());
          }
          
          if (settingsP2.levelP2 !== undefined) {
            const pump2LevelSenseCheckbox = document.getElementById('pump2LevelSense');
            const shouldBeChecked = settingsP2.levelP2 === "YES";
            pump2LevelSenseCheckbox.checked = shouldBeChecked;
            console.log("Set pump2LevelSense checkbox to:", shouldBeChecked, "actual value:", pump2LevelSenseCheckbox.checked);
          }
          
          if (settingsP2.levelTypeP2) {
            document.getElementById('pump2LevelSenseOptions').value = settingsP2.levelTypeP2;
            console.log("Set pump2LevelSenseOptions to:", settingsP2.levelTypeP2);
          }
          
          if (settingsP2.levelNoncP2) {
            document.getElementById('pump2LevelNonc').value = settingsP2.levelNoncP2;
            console.log("Set pump2LevelNonc to:", settingsP2.levelNoncP2);
          }

          // Apply Xtra settings
          if (settingsXtra.extLampInUse !== undefined) {
            const extLampCheckbox = document.getElementById('extLamp');
            const shouldBeChecked = settingsXtra.extLampInUse === "YES";
            extLampCheckbox.checked = shouldBeChecked;
            console.log("Set extLamp checkbox to:", shouldBeChecked, "actual value:", extLampCheckbox.checked);
          }
          
          if (settingsXtra.extLampType) {
            document.getElementById('extLampOptions').value = settingsXtra.extLampType;
            console.log("Set extLampOptions to:", settingsXtra.extLampType);
          }
          
          if (settingsXtra.blockCurrentP1 !== undefined) {
            document.getElementById('blockageManualValue').value = settingsXtra.blockCurrentP1.toString();
            document.getElementById('blockageManual').checked = true;
            console.log("Set blockageManualValue to:", settingsXtra.blockCurrentP1.toString());
          }
          
          if (settingsXtra.blockCurrentP2 !== undefined) {
            document.getElementById('pump2BlockageManualValue').value = settingsXtra.blockCurrentP2.toString();
            document.getElementById('pump2BlockageManual').checked = true;
            console.log("Set pump2BlockageManualValue to:", settingsXtra.blockCurrentP2.toString());
          }

          // IMPORTANT: Apply only visibility logic AFTER settings are loaded, without changing values
          setTimeout(() => {
            console.log("Applying visibility logic only...");
            
            // Apply visibility logic for loaded settings without changing checkbox values
            applyVisibilityOnlyForLoadedSettings();
            
            // ADD: Only trigger pump2 change event if pump2 is actually enabled
            const pump2Enabled = document.getElementById('pump2').checked;
            console.log("Pump2 enabled after settings load:", pump2Enabled);
            
            if (pump2Enabled) {
              console.log("Triggering pump2 change event to apply visibility");
              document.getElementById('pump2').dispatchEvent(new Event('change'));
            } else {
              console.log("Pump2 disabled - skipping change event trigger");
            }
  
            // Clear the loading flag to re-enable TIME/CYCLES logic for user interactions
            window.isLoadingSettings = false;
            
            console.log("Settings loading complete, TIME/CYCLES logic re-enabled");
          }, 50);

          showStatus("Settings loaded from device.");

        } catch (e) {
          window.isLoadingSettings = false; // Clear flag on error
          showStatus("Failed to parse settings from device.", true);
          console.error("applySettingsFromPayload error:", e);
        }

        // ADD: Just this one check at the very end
        if (window.preloadingForSettingsTab) {
          showSettingsTabAfterLoad();
        }
      }

      // Fix the connectMQTTAndQuery function - remove the problematic early return
      function connectMQTTAndQuery(forceSettingsQuery = false) {
        // CHANGE: Only return early if we're on Main tab and have device info and NOT forcing settings query
        if (isAlreadyConnected && client && client.connected && deviceSerial && deviceVersion && !forceSettingsQuery) {
          // Only restore display if we're NOT forcing a settings query
          document.getElementById("serial-number").textContent = deviceSerial;
          document.getElementById("ver-string").textContent = deviceVersion;
          showStatus("");
          return;
        }
        
        // Try URL first, then localStorage, then fail
        serial = getSerialFromURL();
        if (!serial) {
          serial = localStorage.getItem('deviceSerial');
        }
        if (!serial) {
          showStatus("No serial number provided in URL.", true);
          return;
        }
        
        showStatus("Connecting to device...", false);

        // If we already have a connected client and just need settings, skip reconnection
        if (isAlreadyConnected && client && client.connected && forceSettingsQuery) {
          showStatus("Querying device for settings...", false);
          // Clear any existing timeout
          if (queryTimeout) {
            clearTimeout(queryTimeout);
          }
          
          // Reset the settings payload object
          latestSettingsPayload = { p1: null, p2: null, xtra: null };
          
          // Query for all three settings
          client.publish(`a3/${serial}/queryP1Settings`, serial);
          client.publish(`a3/${serial}/queryP2Settings`, serial);
          client.publish(`a3/${serial}/queryXtraSettings`, serial);
          
          queryTimeout = setTimeout(() => {
            showStatus("Failed to load device settings. Device may be offline.", true);
          }, 10000);
          
          return;
        }

        client = mqtt.connect(hivemqBrokerUrl, {
          clientId: 'webClient-' + Math.random().toString(16).substr(2, 8),
          username: hivemqUsername,
          password: hivemqPassword,
          clean: true,
          connectTimeout: 4000,
          reconnectPeriod: 2000,
        });

        client.on('connect', function() {
          isAlreadyConnected = true; // SET FLAG when connected
          showStatus("Connected. Querying device...");
          const responseTopic = `a3/${serial}/serialResponse`;
          const P1testResponseTopic = `a3/${serial}/test/pump1`;
          const P2testResponseTopic = `a3/${serial}/test/pump2`;
          const P1prox1TestTopic = `a3/${serial}/test/p1proxy1`;
          const P1prox2TestTopic = `a3/${serial}/test/p1proxy2`;
          const P2prox1TestTopic = `a3/${serial}/test/p2proxy1`;
          const P2prox2TestTopic = `a3/${serial}/test/p2proxy2`;
          const P1settingsReplyTopic = `a3/${serial}/P1settingsReply`;
          const P2settingsReplyTopic = `a3/${serial}/P2settingsReply`;
          const xtraSettingsReplyTopic = `a3/${serial}/xtraSettingsReply`;

          // Subscribe to all topics first
          client.subscribe(responseTopic);
          client.subscribe(P1testResponseTopic);
          client.subscribe(P2testResponseTopic);
          client.subscribe(P1prox1TestTopic);
          client.subscribe(P1prox2TestTopic);
          client.subscribe(P2prox1TestTopic);
          client.subscribe(P2prox2TestTopic);
          client.subscribe(P1settingsReplyTopic);
          client.subscribe(P2settingsReplyTopic);
          client.subscribe(xtraSettingsReplyTopic);

          // Query serial first
          client.publish(`a3/${serial}/querySerial`, "mainQuery");

          queryTimeout = setTimeout(() => {
            showStatus("No response from device. Please check connection and try again.", true);
          }, 10000);
        });

        client.on('message', function(topic, message) {
          console.log("MQTT message received:", topic, message.toString());
          
          // Serial response handler - THIS SHOULD BE HERE
          if (topic === `a3/${serial}/serialResponse`) {
            try {
              const payload = JSON.parse(message.toString());
              if (payload.serial) {
                deviceSerial = payload.serial; // Store it
                localStorage.setItem('deviceSerial', deviceSerial); // ADD: Store in localStorage
                document.getElementById("serial-number").textContent = payload.serial;
              }
              if (payload.version) {
                deviceVersion = payload.version; // Store it
                localStorage.setItem('deviceVersion', deviceVersion); // ADD: Store in localStorage
                document.getElementById("ver-string").textContent = payload.version;
              }
              showStatus("");
              clearTimeout(queryTimeout);

              // Now that we have the serial response, request all three settings
              client.publish(`a3/${serial}/queryP1Settings`, serial);
              client.publish(`a3/${serial}/queryP2Settings`, serial);
              client.publish(`a3/${serial}/queryXtraSettings`, serial);

            } catch (e) {
              showStatus("Error parsing device response.", true);
            }
          }

          // UPDATE: Modify the settings response handlers to check for pre-loading
          // P1 settings response handler
          if (topic === `a3/${serial}/P1settingsReply`) {
            latestSettingsPayload.p1 = message.toString();
            if (latestSettingsPayload.p1 && latestSettingsPayload.p2 && latestSettingsPayload.xtra) {
              if (window.preloadingForSettingsTab) {
                // Pre-loading complete - apply settings and show tab
                clearTimeout(window.preloadTimeout);
                applySettingsFromPayload(latestSettingsPayload);
                showSettingsTabAfterLoad(); // CHANGED: Call the correct function
              } else {
                // Normal settings loading
                applySettingsFromPayload(latestSettingsPayload);
                showStatus("Settings loaded from device.");
              }
            }
          }

          // P2 settings response handler
          if (topic === `a3/${serial}/P2settingsReply`) {
            latestSettingsPayload.p2 = message.toString();
            if (latestSettingsPayload.p1 && latestSettingsPayload.p2 && latestSettingsPayload.xtra) {
              if (window.preloadingForSettingsTab) {
                // Pre-loading complete - apply settings and show tab
                clearTimeout(window.preloadTimeout);
                applySettingsFromPayload(latestSettingsPayload);
                showSettingsTabAfterLoad(); // CHANGED: Call the correct function
              } else {
                // Normal settings loading
                applySettingsFromPayload(latestSettingsPayload);
                showStatus("Settings loaded from device.");
              }
            }
          }

          // Xtra settings response handler
          if (topic === `a3/${serial}/xtraSettingsReply`) {
            latestSettingsPayload.xtra = message.toString();
            if (latestSettingsPayload.p1 && latestSettingsPayload.p2 && latestSettingsPayload.xtra) {
              if (window.preloadingForSettingsTab) {
                // Pre-loading complete - apply settings and show tab
                clearTimeout(window.preloadTimeout);
                applySettingsFromPayload(latestSettingsPayload);
                showSettingsTabAfterLoad(); // CHANGED: Call the correct function
              } else {
                // Normal settings loading
                applySettingsFromPayload(latestSettingsPayload);
                showStatus("Settings loaded from device.");
              }
            }
          }

          // Pump1 test handler - SWAP THE CLASSES
          if (topic === `a3/${serial}/test/pump1`) {
            const btn = document.getElementById('pump1TestBtn');
            const payload = message.toString();
            
            // Handle pump test button states - SWAPPED CLASSES
            if (btn) {
              if (payload === "running") {
                btn.classList.add('pump-on');      // NOW: Red background
                btn.classList.remove('pump-off');  // Remove green
                btn.textContent = "OFF";           // Label shows OFF (pump is running, button shows OFF to stop it)
                pump1IsOn = true;
              } else if (payload === "stopped") {
                btn.classList.remove('pump-on');   // Remove red
                btn.classList.add('pump-off');     // NOW: Green background
                btn.textContent = "ON";            // Label shows ON (pump is stopped, button shows ON to start it)
                pump1IsOn = false;
              }
            }
            
            // Handle auto calibration responses
            if (p1AutoCalibrating) {
              if (payload === "startingTest") {
                blockageAutoValue.value = 'Pump running';
                console.log("P1 auto calibration: pump running");
              } else if (!isNaN(parseFloat(payload))) {
                // Received a numeric value - this is the calibrated current
                blockageAutoValue.value = payload;
                p1AutoCalibrating = false;
                console.log("P1 auto calibration complete: " + payload);
              }
            }
          }

          // Pump2 test handler - SWAP THE CLASSES
          if (topic === `a3/${serial}/test/pump2`) {
            const btn = document.getElementById('pump2TestBtn');
            const payload = message.toString();
            
            // Handle pump2 test button states - SWAPPED CLASSES
            if (btn) {
              if (payload === "running") {
                btn.classList.add('pump-on');      // NOW: Red background
                btn.classList.remove('pump-off');  // Remove green
                btn.textContent = "OFF";           // Label shows OFF (pump is running, button shows OFF to stop it)
                pump2IsOn = true;
              } else if (payload === "stopped") {
                btn.classList.remove('pump-on');   // Remove red
                btn.classList.add('pump-off');     // NOW: Green background
                btn.textContent = "ON";            // Label shows ON (pump is stopped, button shows ON to start it)
                pump2IsOn = false;
              }
            }
            
            // Handle auto calibration responses for pump2
            if (p2AutoCalibrating) {
              console.log("Processing pump2 auto calibration message:", payload);
              if (payload === "startingTest") {
                pump2BlockageAutoValue.value = 'Pump running';
                console.log("P2 auto calibration: pump running");
              } else if (!isNaN(parseFloat(payload))) {
                // Received a numeric value - this is the calibrated current
                pump2BlockageAutoValue.value = payload;
                p2AutoCalibrating = false;
                console.log("P2 auto calibration complete: " + payload);
              }
            } else {
              console.log("Received pump2 message but not in auto calibration mode");
            }
          }

          // Proxy1 handler - UPDATED TOPIC
          if (topic === `a3/${serial}/test/p1proxy1`) {
            const ind = document.getElementById('proxy1Indicator');
            if (!ind) return;
            const payload = message.toString();
            console.log("Received p1proxy1 message:", payload);
            if (payload === "on") {
              ind.classList.remove('proxy-off');
              ind.classList.add('proxy-on');
              ind.textContent = "ON";
            } else if (payload === "off") {
              ind.classList.remove('proxy-on');
              ind.classList.add('proxy-off');
              ind.textContent = "OFF";
            }
          }

          // Proxy2 handler - UPDATED TOPIC
          if (topic === `a3/${serial}/test/p1proxy2`) {
            const ind = document.getElementById('proxy2Indicator');
            if (!ind) return;
            const payload = message.toString();
            console.log("Received p1proxy2 message:", payload);
            if (payload === "on") {
              ind.classList.remove('proxy-off');
              ind.classList.add('proxy-on');
              ind.textContent = "ON";
            } else if (payload === "off") {
              ind.classList.remove('proxy-on');
              ind.classList.add('proxy-off');
              ind.textContent = "OFF";
            }
          }

          // ADD Pump2 Proxy1 handler
          if (topic === `a3/${serial}/test/p2proxy1`) {
            const ind = document.getElementById('pump2Proxy1Indicator');
            if (!ind) return;
            const payload = message.toString();
            console.log("Received p2proxy1 message:", payload);
            if (payload === "on") {
              ind.classList.remove('proxy-off');
              ind.classList.add('proxy-on');
              ind.textContent = "ON";
            } else if (payload === "off") {
              ind.classList.remove('proxy-on');
              ind.classList.add('proxy-off');
              ind.textContent = "OFF";
            }
          }

          // ADD Pump2 Proxy2 handler
          if (topic === `a3/${serial}/test/p2proxy2`) {
            const ind = document.getElementById('pump2Proxy2Indicator');
            if (!ind) return;
            const payload = message.toString();
            console.log("Received p2proxy2 message:", payload);
            if (payload === "on") {
              ind.classList.remove('proxy-off');
              ind.classList.add('proxy-on');
              ind.textContent = "ON";
            } else if (payload === "off") {
              ind.classList.remove('proxy-on');
              ind.classList.add('proxy-off');
              ind.textContent = "OFF";
            }
          }
        });

        client.on('error', function() {
          showStatus("MQTT connection error.", true);
        });
      }

      document.getElementById("backBtn").onclick = function() {
        window.location.href = "index.html";
      };
      
      // Only connect if we don't have device info stored
      const storedSerial = localStorage.getItem('deviceSerial');
      const storedVersion = localStorage.getItem('deviceVersion');

      if (storedSerial) {
        deviceSerial = storedSerial;
        document.getElementById("serial-number").textContent = deviceSerial;
      }
      if (storedVersion) {
        deviceVersion = storedVersion;
        document.getElementById("ver-string").textContent = deviceVersion;
      }

      if (!deviceSerial && !deviceVersion) {
        connectMQTTAndQuery();
      } else {
        showStatus("");
      }

      // Add this function to handle the Save Settings button
function saveSettings() {
  // Now proceed with the actual save functionality
  const validationErrors = validateAllFields();
  
  if (validationErrors.length > 0) {
    const errorMessage = "Please fill in the following required fields:\n\n" + validationErrors.join("\n");
    alert(errorMessage);
    return;
  }
  
  // All fields are valid, compile and send MQTT messages
  try {
    const p1Settings = compileP1Settings();
    const p2Settings = compileP2Settings();
    const xtraSettings = compileXtraSettings();
    
    if (client && client.connected && serial) {
      // FIXED: Send to the new save topic names
      client.publish(`a3/${serial}/P1settingsSave`, p1Settings, {qos: 1, retain: false});
      client.publish(`a3/${serial}/P2settingsSave`, p2Settings, {qos: 1, retain: false});
      client.publish(`a3/${serial}/xtraSettingsSave`, xtraSettings, {qos: 1, retain: false});
      
      console.log("Sent P1 settings:", p1Settings);
      console.log("Sent P2 settings:", p2Settings);
      console.log("Sent Xtra settings:", xtraSettings);
      
      // Switch to main tab and restore device info after successful save
      setTimeout(() => {
        // Trigger the main tab click which already has the restore logic
        tabMainBtn.click();
        showStatus("Settings saved successfully!", false);
      }, 500);
      
      // Optionally close test mode and return to main settings
      const testModePanel = document.getElementById('testModePanel');
      if (testModePanel && testModePanel.style.display !== 'none') {
        sendPumpOffMessages();
        testModePanel.style.display = 'none';
        document.getElementById('settingsForm').style.display = '';
      }
      
    } else {
      alert("Error: Not connected to device. Cannot save settings.");
    }
    
  } catch (error) {
    console.error("Error compiling settings:", error);
    alert("Error saving settings: " + error.message);
  }
}

// Validate all visible fields
function validateAllFields() {
  const errors = [];
  
  // Check main mode fields - FIX ELEMENT IDS
  if (!document.getElementById('modeSelect').value) {
    errors.push(" Main Mode (Pump1)");
  }
  
  if (!document.getElementById('pauseTime').value) {
    errors.push(" Pause Time (Pump1)");
  }
  
  if (!document.getElementById('timeCyclesSelect').value) {
    errors.push(" Time/Cycles Mode (Pump1)");
  }
  
  if (!document.getElementById('timeCyclesValue').value) {
    errors.push(" Time/Cycles Value (Pump1)");
  }
  
  // Check proxy fields if they are enabled and visible
  if (document.getElementById('proxy1').checked) {
    // No required field for proxy1 dwell time in validation
  }
  
  if (document.getElementById('proxy2').checked) {
    if (!document.getElementById('dwellTime2').value) {
      errors.push(" Dwell Time 2 (Pump1)");
    }
  }
  
  // Check level sense fields if enabled
  if (document.getElementById('levelSense').checked) {
    if (!document.getElementById('levelSenseOptions').value) {
      errors.push(" Level Sense Type (Pump1)");
    }
    
    // Check level nonc if LLO is selected
    if (document.getElementById('levelSenseOptions').value === 'LLO') {
      if (!document.getElementById('levelNonc').value) {
        errors.push(" Level N/O or N/C (Pump1)");
      }
    }
  }
  
  // Check blockage current field
  if (document.getElementById('blockageManual').checked) {
    if (!document.getElementById('blockageManualValue').value) {
      errors.push(" Blockage Current Manual Value (Pump1)");
    }
  }
  
  // Check Pump2 fields if Pump2 is enabled
  if (document.getElementById('pump2').checked) {
    if (!document.getElementById('pump2Mode').value) { // FIX ELEMENT ID
      errors.push(" Main Mode (Pump2)");
    }
    
    if (!document.getElementById('pump2PauseTime').value) {
      errors.push(" Pause Time (Pump2)");
    }
    
    if (!document.getElementById('pump2TimeCyclesSelect').value) {
      errors.push(" Time/Cycles Mode (Pump2)");
    }
    
    if (!document.getElementById('pump2TimeCyclesValue').value) {
      errors.push(" Time/Cycles Value (Pump2)");
    }
    
    // Check pump2 proxy fields if enabled
    if (document.getElementById('pump2Proxy1').checked) {
      if (!document.getElementById('pump2DwellTime1').value) {
        errors.push(" Dwell Time 1 (Pump2)");
      }
    }
    
    if (document.getElementById('pump2Proxy2').checked) {
      if (!document.getElementById('pump2DwellTime2').value) {
        errors.push(" Dwell Time 2 (Pump2)");
      }
    }
    
    // Check pump2 level sense fields if enabled
    if (document.getElementById('pump2LevelSense').checked) {
      if (!document.getElementById('pump2LevelSenseOptions').value) {
        errors.push(" Level Sense Type (Pump2)");
      }
      
      if (document.getElementById('pump2LevelSenseOptions').value === 'LLO') {
        if (!document.getElementById('pump2LevelNonc').value) {
          errors.push(" Level N/O or N/C (Pump2)");
        }
      }
    }
    
    // Check pump2 blockage current
    if (document.getElementById('pump2BlockageManual').checked) {
      if (!document.getElementById('pump2BlockageManualValue').value) {
        errors.push(" Blockage Current Manual Value (Pump2)");
      }
    }
  }
  
  // Check external lamp fields if enabled
  if (document.getElementById('extLamp').checked) {
   
    if (!document.getElementById('extLampOptions').value) {
      errors.push(" Lamp Type");
    }
  }
  
  return errors;
}

// Compile P1 settings in the same format as received from ESP32
function compileP1Settings() {
  const p1Settings = {
    modeP1: document.getElementById('modeSelect').value,
    pauseTimeP1: hmsToSeconds(document.getElementById('pauseTime').value) || 0,
    runModeP1: document.getElementById('timeCyclesSelect').value,
    proxy1P1: document.getElementById('proxy1').checked ? "YES" : "NO",
    proxy2P1: document.getElementById('proxy2').checked ? "YES" : "NO",
    levelP1: document.getElementById('levelSense').checked ? "YES" : "NO"
  };
  
  // Handle time/cycles value conversion
  const timeCyclesValue = document.getElementById('timeCyclesValue').value;
  if (document.getElementById('timeCyclesSelect').value === 'TIME') {
    p1Settings.timeCyclesP1 = msToSeconds(timeCyclesValue);
  } else {
    p1Settings.timeCyclesP1 = parseInt(timeCyclesValue) || 0;
  }
  
  // Add proxy dwell times if proxies are enabled
  if (document.getElementById('proxy1').checked) {
    p1Settings.dwellTimeP1Px1 = parseInt(document.getElementById('dwellTime1').value) || 0;
  }
  
  if (document.getElementById('proxy2').checked) {
    p1Settings.dwellTimeP1Px2 = parseInt(document.getElementById('dwellTime2').value) || 0;
  }
 
  // Add level sense settings if enabled
  if (document.getElementById('levelSense').checked) {
    p1Settings.levelTypeP1 = document.getElementById('levelSenseOptions').value;
    
    if (document.getElementById('levelSenseOptions').value === 'LLO') {
      p1Settings.levelNoncP1 = document.getElementById('levelNonc').value;
    }
  }
  
  return JSON.stringify(p1Settings);
}

// Compile P2 settings in the same format as received from ESP32
function compileP2Settings() {
  const pump2InUse = document.getElementById('pump2').checked;
  
  const p2Settings = {
    pump2InUse: pump2InUse ? "YES" : "NO",
    modeP2: document.getElementById('pump2Mode').value,
    pauseTimeP2: hmsToSeconds(document.getElementById('pump2PauseTime').value) || 0,
    runModeP2: document.getElementById('pump2TimeCyclesSelect').value,
    proxy1P2: document.getElementById('pump2Proxy1').checked ? "YES" : "NO",
    proxy2P2: document.getElementById('pump2Proxy2').checked ? "YES" : "NO",
    levelP2: document.getElementById('pump2LevelSense').checked ? "YES" : "NO"
  };
  
  // Handle time/cycles value conversion
  const pump2TimeCyclesValue = document.getElementById('pump2TimeCyclesValue').value;
  if (document.getElementById('pump2TimeCyclesSelect').value === 'TIME') {
    p2Settings.timeCyclesP2 = msToSeconds(pump2TimeCyclesValue);
  } else {
    p2Settings.timeCyclesP2 = parseInt(pump2TimeCyclesValue) || 0;
  }
  
  // Add proxy dwell times if proxies are enabled
  if (document.getElementById('pump2Proxy1').checked) {
    p2Settings.dwellTimeP2Px1 = parseInt(document.getElementById('pump2DwellTime1').value) || 0;
  }
  
  if (document.getElementById('pump2Proxy2').checked) {
    p2Settings.dwellTimeP2Px2 = parseInt(document.getElementById('pump2DwellTime2').value) || 0;
  }
  
  // Add level sense settings if enabled
  if (document.getElementById('pump2LevelSense').checked) {
    p2Settings.levelTypeP2 = document.getElementById('pump2LevelSenseOptions').value;
    
    if (document.getElementById('pump2LevelSenseOptions').value === 'LLO') {
      p2Settings.levelNoncP2 = document.getElementById('pump2LevelNonc').value;
    }
  }
  
  return JSON.stringify(p2Settings); // RETURN JSON STRING, not object
}

// Compile extra settings in the same format as received from ESP32
function compileXtraSettings() {
  const xtraSettings = {
    extLampInUse: document.getElementById('extLamp').checked ? "YES" : "NO"  // FIXED: Changed field name
  };
  
  // Add lamp type if external lamp is enabled
  if (document.getElementById('extLamp').checked) {
    xtraSettings.extLampType = document.getElementById('extLampOptions').value;  // FIXED: Changed field name
  }
  
  // Add blockage current values
  if (document.getElementById('blockageManual').checked && document.getElementById('blockageManualValue').value) {
    xtraSettings.blockCurrentP1 = parseFloat(document.getElementById('blockageManualValue').value) || 0;
  } else if (document.getElementById('blockageAuto').checked && document.getElementById('blockageAutoValue').value) {
    xtraSettings.blockCurrentP1 = parseFloat(document.getElementById('blockageAutoValue').value) || 0;  // FIXED: Removed duplicate line
  }
  
  // Add pump2 blockage current if pump2 is enabled
  if (document.getElementById('pump2').checked) {
    if (document.getElementById('pump2BlockageManual').checked && document.getElementById('pump2BlockageManualValue').value) {
      xtraSettings.blockCurrentP2 = parseFloat(document.getElementById('pump2BlockageManualValue').value) || 0;
    } else if (document.getElementById('pump2BlockageAuto').checked && document.getElementById('pump2BlockageAutoValue').value) {
      xtraSettings.blockCurrentP2 = parseFloat(document.getElementById('pump2BlockageAutoValue').value) || 0;
    }
  }
  
  return JSON.stringify(xtraSettings);
}

// Helper function to convert MM:SS to seconds
function msToSeconds(timeString) {

  if (!timeString || !timeString.includes(':')) return 0;
  
  const parts = timeString.split(':');
  if (parts.length !== 2) return 0;
  
  const minutes = parseInt(parts[0]) || 0;
  const seconds = parseInt(parts[1]) || 0;
  
  return (minutes * 60) + seconds;
}

// Update the Save Settings button click handler
const saveSettingsBtn = document.getElementById('saveSettingsBtn');
if (saveSettingsBtn) {
  saveSettingsBtn.onclick = saveSettings;
  console.log("Save Settings button clicked.");
}

// Also update the test mode save button
const testModeSaveBtn = document.getElementById('testModeSaveBtn');
if (testModeSaveBtn) {
  testModeSaveBtn.onclick = saveSettings;
}

// Proxy dependency logic - ADD AFTER setupShowHideCheckbox calls
document.getElementById('timeCyclesSelect').addEventListener('change', function() {
  updateTimeCyclesLabel();
  
  // Don't apply auto-logic during settings loading
  if (window.isLoadingSettings) return;
  
  // CYCLE mode: auto-select proxy1, show proxy2 (but don't select it)
  if (this.value === 'CYCLE') {
    document.getElementById('proxy1').checked = true;
    document.getElementById('dwellTime1Row').style.display = '';
    // Show proxy2 row since proxy1 is now enabled, but don't check it
    document.querySelector('[for="proxy2"]').parentElement.style.display = '';
  } 
  // TIME mode: clear proxy1, hide and clear proxy2
  else if (this.value === 'TIME') {
    document.getElementById('proxy1').checked = false;
    document.getElementById('dwellTime1Row').style.display = 'none';
    document.getElementById('proxy2').checked = false;
    document.getElementById('dwellTime2Row').style.display = 'none';
    document.querySelector('[for="proxy2"]').parentElement.style.display = 'none';
  }
});

document.getElementById('proxy1').addEventListener('change', function() {
  document.getElementById('dwellTime1Row').style.display = this.checked ? '' : 'none';
  
  // Don't apply auto-logic during settings loading
  if (window.isLoadingSettings) return;
  
  // If proxy1 unchecked, hide and uncheck proxy2
  if (!this.checked) {
    document.querySelector('[for="proxy2"]').parentElement.style.display = 'none';
    document.getElementById('proxy2').checked = false;
    document.getElementById('dwellTime2Row').style.display = 'none';
  } else {
    // If proxy1 checked, show proxy2 (but don't auto-select it)
    document.querySelector('[for="proxy2"]').parentElement.style.display = '';
  }
});

// Pump2 proxy dependency logic
document.getElementById('pump2TimeCyclesSelect').addEventListener('change', function() {
  updatePump2TimeCyclesLabel();
  
  // Don't apply auto-logic during settings loading
  if (window.isLoadingSettings) return;
  
  // CYCLE mode: auto-select proxy1, show proxy2 (but don't select it)
  if (this.value === 'CYCLE') {
    document.getElementById('pump2Proxy1').checked = true;
    document.getElementById('pump2DwellTime1Row').style.display = '';
    // Show proxy2 row since proxy1 is now enabled
    const pump2Proxy2Row = document.querySelector('[for="pump2Proxy2"]').parentElement;
    if (pump2Proxy2Row) {
      pump2Proxy2Row.style.display = '';
    }
  } 
  // TIME mode: clear proxy1, hide and clear proxy2
  else if (this.value === 'TIME') {
    document.getElementById('pump2Proxy1').checked = false;
    document.getElementById('pump2DwellTime1Row').style.display = 'none';
    document.getElementById('pump2Proxy2').checked = false;
    document.getElementById('pump2DwellTime2Row').style.display = 'none';
    const pump2Proxy2Row = document.querySelector('[for="pump2Proxy2"]').parentElement;
    if (pump2Proxy2Row) {
      pump2Proxy2Row.style.display = 'none';
    }
  }
});

document.getElementById('pump2Proxy1').addEventListener('change', function() {
  document.getElementById('pump2DwellTime1Row').style.display = this.checked ? '' : 'none';
  
  // Don't apply auto-logic during settings loading
  if (window.isLoadingSettings) return;
  
  // If proxy1 unchecked, hide and uncheck proxy2
  if (!this.checked) {
    const pump2Proxy2Row = document.querySelector('[for="pump2Proxy2"]').parentElement;
    if (pump2Proxy2Row) {
      pump2Proxy2Row.style.display = 'none';
    }
    document.getElementById('pump2Proxy2').checked = false;
    document.getElementById('pump2DwellTime2Row').style.display = 'none';
  } else {
    // If proxy1 checked, show proxy2 (but don't auto-select it)
    const pump2Proxy2Row = document.querySelector('[for="pump2Proxy2"]').parentElement;
    if (pump2Proxy2Row) {
      pump2Proxy2Row.style.display = '';
    }
  }
});

// Function to handle Pump2 being enabled/disabled
function onPump2Toggle() {
  const pump2Enabled = document.getElementById('pump2').checked;
  
  if (pump2Enabled) {
    // Pump2 was just enabled - apply proxy visibility logic
    setTimeout(() => {
      applyPump2ProxyVisibility();
    }, 10); // Small delay to let setupShowHideCheckbox complete
  }
}

// Add event listener to Pump2 checkbox
document.getElementById('pump2').addEventListener('change', onPump2Toggle);

// Function to apply Pump2 proxy visibility based on current states
function applyPump2ProxyVisibility() {
  const pump2InUse = document.getElementById('pump2').checked;
  if (!pump2InUse) return;
  
  const pump2Proxy1Checked = document.getElementById('pump2Proxy1').checked;
  const pump2TimeCyclesMode = document.getElementById('pump2TimeCyclesSelect').value;
  const pump2Proxy2Row = document.querySelector('[for="pump2Proxy2"]').parentElement;
  
  if (pump2Proxy2Row) {
    // In CYCLE mode, Proxy1 should be auto-checked and Proxy2 should be visible
    if (pump2TimeCyclesMode === 'CYCLE') {
      pump2Proxy2Row.style.display = '';
    }
    // In TIME mode, only show Proxy2 if Proxy1 is checked
    else if (pump2TimeCyclesMode === 'TIME') {
      if (pump2Proxy1Checked) {
        pump2Proxy2Row.style.display = '';
      } else {
        pump2Proxy2Row.style.display = 'none';
        document.getElementById('pump2Proxy2').checked = false;
        document.getElementById('pump2DwellTime2Row').style.display = 'none';
      }
    }
  }
  
  // Apply dwell time visibility
  document.getElementById('pump2DwellTime1Row').style.display = pump2Proxy1Checked ? '' : 'none';
  document.getElementById('pump2DwellTime2Row').style.display = document.getElementById('pump2Proxy2').checked ? '' : 'none';
}

// Function to apply initial proxy visibility states
function applyInitialProxyVisibility() {
  // Apply Pump1 proxy visibility
  const proxy1Checked = document.getElementById('proxy1').checked;
  const timeCyclesMode = document.getElementById('timeCyclesSelect').value;
  
  if (timeCyclesMode === 'TIME' && !proxy1Checked) {
    const proxy2Row = document.querySelector('[for="proxy2"]').parentElement;
    if (proxy2Row) {
      proxy2Row.style.display = 'none';
    }
  }
  
  // Apply Pump2 proxy visibility
  applyPump2ProxyVisibility();
}

document.getElementById('wifiFormMain').addEventListener('submit', function(e) {
  e.preventDefault();
  
  const ssid = document.getElementById('ssid-main').value;
  const password = document.getElementById('password-main').value;
  
  if (client && client.connected && serial) {
    const wifiSettings = {
      ssid: ssid,
      password: password
    };
    
    client.publish(`a3/${serial}/wifiSettings`, JSON.stringify(wifiSettings));
    showStatus("WiFi settings saved!", false);
    
    // Clear the form
    document.getElementById('ssid-main').value = '';
    document.getElementById('password-main').value = '';
  } else {
    showStatus("Error: Not connected to device.", true);
  }
});

// NEW: Apply visibility logic for loaded settings without changing checkbox values
function applyVisibilityOnlyForLoadedSettings() {
  // Apply P1 visibility based on loaded settings
  const proxy1Checked = document.getElementById('proxy1').checked;
  const proxy2Checked = document.getElementById('proxy2').checked;
  const timeCyclesMode = document.getElementById('timeCyclesSelect').value;
  
  // Show/hide dwell time rows based on proxy states
  document.getElementById('dwellTime1Row').style.display = proxy1Checked ? '' : 'none';
  document.getElementById('dwellTime2Row').style.display = proxy2Checked ? '' : 'none';
  
  // Show/hide proxy2 based on TIME mode rules and proxy1 state
  const proxy2Row = document.querySelector('[for="proxy2"]').parentElement;
  if (proxy2Row) {
    if (timeCyclesMode === 'TIME' && !proxy1Checked) {
      proxy2Row.style.display = 'none';
    } else {
      proxy2Row.style.display = proxy1Checked ? '' : 'none';
    }
  }
  
  // FIXED: Handle pump2 settings group visibility correctly
  const pump2Checked = document.getElementById('pump2').checked;
  const pump2SettingsGroup = document.getElementById('pump2SettingsGroup');
  if (pump2SettingsGroup) {
    pump2SettingsGroup.style.display = pump2Checked ? '' : 'none';
    console.log("applyVisibilityOnlyForLoadedSettings: Set pump2 settings visibility to:", pump2Checked ? 'visible' : 'hidden');
  }
  
  // Apply P2 visibility if pump2 is enabled
  if (pump2Checked) {
    const pump2Proxy1Checked = document.getElementById('pump2Proxy1').checked;
    const pump2Proxy2Checked = document.getElementById('pump2Proxy2').checked;
    const pump2TimeCyclesMode = document.getElementById('pump2TimeCyclesSelect').value;
    
    // Show/hide pump2 dwell time rows
    document.getElementById('pump2DwellTime1Row').style.display = pump2Proxy1Checked ? '' : 'none';
    document.getElementById('pump2DwellTime2Row').style.display = pump2Proxy2Checked ? '' : 'none';
    
    // Show/hide pump2 proxy2 based on TIME mode rules and proxy1 state
    const pump2Proxy2Row = document.querySelector('[for="pump2Proxy2"]').parentElement;
    if (pump2Proxy2Row) {
      if (pump2TimeCyclesMode === 'TIME' && !pump2Proxy1Checked) {
        pump2Proxy2Row.style.display = 'none';
      } else {
        pump2Proxy2Row.style.display = pump2Proxy1Checked ? '' : 'none';
      }
    }
  }
  
  console.log("Visibility applied based on loaded settings");
}
    </script>
  </body>
</html>